---
title: "Group project"
author: "Yun Zhu"
date: "28/02/2022"
output: pdf_document
---

```{r setup, include=FALSE}
library(haven)
library(naniar)
library(gtsummary)
library(pROC)
library(dplyr)
library(caret)
library(polycor)
library(tidyr)
library(Hmisc)
library(mice)
library(here)
library(knitr)

frax_risk <- read_sas(here("data","frax_risk.sas7bdat"), NULL)
frax_risk <-as.data.frame(frax_risk)
```


```{r check missing value}
# delete the observations first
# 
# replace "don't know" and "refused" with NA
dn9<-c("ALQ101","DBQ197","DBQ229","DIQ010","DIQ220","MCQ190","MCQ160C","OSQ010A","OSQ010B","OSQ010C","OSQ040AA","OSQ040BA","OSQ040CA","OSQ070","OSQ130","OSQ170","OSQ200","OSQ140U","SMQ020")
dn999<-c("ALQ130","ALQ140Q","DID040","OSQ140Q")
dn9999<-c("OSQ020A","OSQ020B","OSQ020C","WHD020","WHD110","WHD010")
# no column named WHD140 in this data set
dn99999<-c("MCQ160A","MCQ180A","MCQ180C","MCQ160L","MCQ170L","MCQ180L")
frax_risk[,dn9]<-na_if(frax_risk[,dn9],9)
frax_risk[,dn9]<-na_if(frax_risk[,dn9],7)
frax_risk[,dn999]<-na_if(frax_risk[,dn999],999)
frax_risk[,dn999]<-na_if(frax_risk[,dn999],777)
frax_risk[,dn9999]<-na_if(frax_risk[,dn9999],9999)
frax_risk[,dn9999]<-na_if(frax_risk[,dn9999],7777)
frax_risk[,dn99999]<-na_if(frax_risk[,dn99999],99999)
frax_risk[,dn99999]<-na_if(frax_risk[,dn99999],77777)
# check missing values of all variables
gg_miss_var(frax_risk, show_pct = TRUE)
# pick variables with missing value proportion over 50%
frax_risk_50<-frax_risk[, which(colMeans(is.na(frax_risk)) > 0.5)]
gg_miss_var(frax_risk_50, show_pct = TRUE)
```

```{r check variables with missing value less than 50%}
# missing value more than 20%
frax_risk_2050<-frax_risk[, which((colMeans(is.na(frax_risk)) <= 0.5)&(colMeans(is.na(frax_risk)) > 0.2))]
gg_miss_var(frax_risk_2050, show_pct = TRUE)
length(frax_risk_2050)
# missing value less than 20%
frax_risk_20<-frax_risk[, which(colMeans(is.na(frax_risk)) <= 0.2)]
gg_miss_var(frax_risk_20, show_pct = TRUE)
```

```{r dataframe}
# create a data frame 
df<-frax_risk[, which(colMeans(is.na(frax_risk)) <= 0.4)]
# remove duplicate rows
df<-distinct(df)
# check features with low variance
nearZeroVar(df,saveMetrics = TRUE)
# check features with high correlation
Corr <- NULL
# Chi-square test between two categorical variables. 
# Pearson’s Test between two continuous variables
# Point-Biserial Correlation One categorical and one quantitative variable.
discrete <- c("RIAGENDR","RIDRETH1","SDMVPSU","OSQ010A","OSQ010B","OSQ010C","OSQ130","OSQ170","OSQ200","SMQ020" ,               "ALQ101","ALQ130","ALQ140Q","DIQ010","MCQ160A","MCQ160C","MCQ160L","DBQ197","DBQ229")

complete <- na.omit(df)
for(i in 2:(ncol(complete)-1)){
  for(j in (i+1):ncol(complete)){
    if((names(complete)[i] %in% discrete + names(complete)[j] %in% discrete) != 1){
      Corr <- rbind(Corr, c(names(complete)[i],names(complete)[j], cor.test(complete[,i], complete[,j], method = "pearson")$estimate))
    }else
      Corr <- rbind(Corr, c(names(complete)[i],names(complete)[j], polyserial(complete[,i],complete[,j])))
  }
}
#Corr(BMXBMI, WHD020) = 0.83974550051039
df <-  subset(df, select = -c(SEQN,WHD010,WHD020,WHD110)) # remove high correlated
df <- df[-which(is.na(df$OSQ010A)|is.na(df$OSQ010B)|is.na(df$OSQ010C)),]

# multiple imputation
(fmla <- as.formula(paste(" ~ ", paste(colnames(df), collapse=" +"))))
impute_arg <- aregImpute(formula = fmla, data = df, n.impute = 10, nk=0 )
# Get the imputed values
impute <- impute.transcan(impute_arg, data=df, imputation=1, list.out=TRUE, pr=FALSE, check=FALSE)

# convert the list to the database
impute <- as.data.frame(do.call(cbind,impute))
format(colSums(is.na(df[, sapply(df, anyNA)])) / nrow(df)*100, digits = 2) #DXXOSBMD 
index.na <- which(is.na(df$DXXOSBMD))
Comparison <- data.frame(DXXOSBMD = c(df$DXXOSBMD[-index.na],impute$DXXOSBMD[index.na]),
                         Label = c(rep("Observed",(nrow(impute)-length(index.na))),rep("imputed",length(index.na))))

# remove Survey weights and sampling unit information
impute<-impute[,-c(4:6)]
impute<-impute%>% mutate(fracture=as.factor(ifelse((OSQ010A=="1"|OSQ010B=="1"|OSQ010C=="1"), 1, 0))) # add fracture indicator
impute$fracture <- as.numeric(impute$fracture)-1
frax_risk_men<-impute%>%filter(RIAGENDR==1)
frax_risk_women<-impute%>%filter(RIAGENDR==2)
impute$RIAGENDR <- as.factor(impute$RIAGENDR)
impute$RIDRETH1 <- as.factor(impute$RIDRETH1)
```


```{r imputaion plot}
require(qqplotr)
# Histogram with density plot
p1 <- ggplot(Comparison, aes(DXXOSBMD, colour = Label)) + 
 geom_histogram(aes(y=..density..), colour="lightblue", fill="white")+
 geom_density(alpha=.2, fill="#FF6666") 

# Interleaved histograms
p2 <- ggplot(Comparison, aes(DXXOSBMD, colour = Label)) +
  geom_histogram(fill="white", alpha=0.5)+
  theme(legend.position="right")

#quantile–quantile 
p3 <- ggplot(data = Comparison, mapping = aes(sample = DXXOSBMD, color = Label,fill = Label)) +
    stat_qq_band(alpha=0.3) +
    stat_qq_line() +
    stat_qq_point(alpha=0.1) +
    labs(x = "DXXOSBMD Observed", y = "DXXOSBMD Imputed")
#cumulative distribution
p4 <- ggplot(Comparison, aes(DXXOSBMD, colour = Label)) +
  stat_ecdf() +
    labs(x = "DXXOSBMD", y = "Cumulative Probability")
library(cowplot)
ggdraw() +
  draw_plot(p1, x = 0, y = .5, width = .5, height = .5) +
  draw_plot(p2, x = .5, y = .5, width = .5, height = .5) +
  draw_plot(p3, x = 0, y = 0, width = .5, height = 0.5) +
  draw_plot(p4, x = 0.5, y = 0, width = .5, height = 0.5)

table <- 
  tbl_summary(
    impute,
    by = RIAGENDR # split table by group
  ) %>%
  add_n() %>% # add column with total number of non-missing observations
  add_p() %>% # test for a difference between groups
  modify_header(label = "**Variable**") %>% # update the column header
  bold_labels() 
table
```


```{r LASSO}
library(glmnet)

# Step 1: prepare features for modeling
fracture_variables<-c("OSQ010A","OSQ010B","OSQ010C","fracture")
individual_variables<-c("RIAGENDR","RIDRETH1","RIDAGEYR")
frax_risk_BMD<-dplyr::select(impute,contains("BMD"))
frax_risk_nonBMD<-impute[,!(names(impute) %in% names(frax_risk_BMD)) 
                         & !(names(impute) %in% fracture_variables)
                         & !(names(impute) %in% individual_variables)]
BMD_variables<-colnames(frax_risk_BMD)
nonBMD_variables<-colnames(frax_risk_nonBMD)

#q1
x1 <-scale(model.matrix(fracture~., impute[,!names(impute) %in% c("OSQ010A","OSQ010B","OSQ010C")])[,-1])
y1 <- impute$fracture
set.seed(123)
cv.l1 <- cv.glmnet(x1,y1,family="binomial",nfolds = 5,alpha=1,penalty.factor =c(rep(0,10),rep(1,10),rep(0,8)))
best_lambda.l1<-cv.l1$lambda.min
set.seed(123)
l.mod1<- glmnet(x1,y1,family="binomial",alpha=1,lambda = best_lambda.l1,penalty.factor =c(rep(0,10),rep(1,10),rep(0,8)))
coef.l.min1 <- coef(l.mod1)
feature1 <- rownames(coef.l.min1)[coef.l.min1[,1]!=0][-1]
BMDfeature1<-grep("BMD",feature1,value=T)
BMDfeature1

#q2
x.hip <-scale(model.matrix(OSQ010A~., impute[,!names(impute) %in% c("fracture","OSQ010B","OSQ010C")])[,-1])
y.hip <- impute$OSQ010A
set.seed(123)
cv.l.hip <- cv.glmnet(x.hip,y.hip,family="binomial",nfolds = 5,alpha=1,penalty.factor =c(rep(0,10),rep(1,10),rep(0,8)))
best_lambda.l.hip<-cv.l.hip$lambda.min
set.seed(123)
l.mod.hip<- glmnet(x.hip,y.hip,family="binomial",alpha=1,lambda = best_lambda.l.hip,penalty.factor =c(rep(0,10),rep(1,10),rep(0,8)))
coef.l.min.hip<- coef(l.mod.hip)
feature.hip <- rownames(coef.l.min.hip)[coef.l.min.hip[,1]!=0][-1]
BMDfeature.hip<-grep("BMD",feature.hip,value=T)
BMDfeature.hip
#q3
## men
x.men <-scale(model.matrix(fracture~., frax_risk_men[,!names(frax_risk_men) %in% c("RIAGENDR","OSQ010A","OSQ010B","OSQ010C")])[,-1])
y.men <- frax_risk_men$fracture
set.seed(123)
cv.l.men <- cv.glmnet(x.men,y.men,family="binomial",nfolds = 5,alpha=1,penalty.factor =c(rep(0,6),rep(1,10),rep(0,8)))
best_lambda.l.men<-cv.l.men$lambda.min
set.seed(123)
l.mod.men<- glmnet(x.men,y.men,family="binomial",alpha=1,lambda = best_lambda.l.men,penalty.factor =c(rep(0,6),rep(1,10),rep(0,8)))
coef.l.min.men <- coef(l.mod.men)
feature.men <- rownames(coef.l.min.men)[coef.l.min.men[,1]!=0][-1]
BMDfeature.men<-grep("BMD",feature.men,value=T)
BMDfeature.men

## women
x.women <-scale(model.matrix(fracture~., frax_risk_women[,!names(frax_risk_women) %in% c("RIAGENDR","OSQ010A","OSQ010B","OSQ010C")])[,-1])
y.women <- frax_risk_women$fracture
set.seed(123)
cv.l.women <- cv.glmnet(x.women,y.women,family="binomial",nfolds = 5,alpha=1,penalty.factor =c(rep(0,6),rep(1,10),rep(0,8)))
best_lambda.l.women<-cv.l.women$lambda.min
set.seed(123)
l.mod.women<- glmnet(x.women,y.women,family="binomial",alpha=1,lambda = best_lambda.l.women,penalty.factor =c(rep(0,6),rep(1,10),rep(0,8)))
coef.l.min.women <- coef(l.mod.women)
feature.women <- rownames(coef.l.min.women)[coef.l.min.women[,1]!=0][-1]
BMDfeature.women<-grep("BMD",feature.women,value=T)
BMDfeature.women

```

```{r Bayesian Logistic}
# Step 1: prepare features for modeling

fracture_variables<-c("OSQ010A","OSQ010B","OSQ010C","fracture")
individual_variables<-c("RIAGENDR","RIDRETH1","RIDAGEYR")
frax_risk_BMD<-dplyr::select(impute,contains("BMD"))
frax_risk_nonBMD<-impute[,!(names(impute) %in% names(frax_risk_BMD)) 
                         & !(names(impute) %in% fracture_variables)
                         & !(names(impute) %in% individual_variables)]
BMD_variables<-colnames(frax_risk_BMD)
nonBMD_variables<-colnames(frax_risk_nonBMD)

impute[,nonBMD_variables[-10]] <- apply(impute[,nonBMD_variables[-10]],2,as.factor)
# Step 1: Creating a list of all the variables
library(coda)
library(rjags)
library(R2jags)
jagsdata <- as.list(impute[,c(BMD_variables,nonBMD_variables,individual_variables,"fracture")])
jagsdata_men <- as.list(frax_risk_men[,c(BMD_variables,nonBMD_variables,individual_variables,"fracture")])
jagsdata_women <- as.list(frax_risk_women[,c(BMD_variables,nonBMD_variables,individual_variables,"fracture")])
jagsdata$N <- nrow(impute)
jagsdata_men$N <- nrow(frax_risk_men)
jagsdata_women$N <- nrow(frax_risk_women)
# Step 2: Specifying the growth curve model
blogistic <- cat("
model {
for (i in 1:N) {
    logit(p[i]) <- a + b1*DXXOFBMD[i] + b2*DXXNKBMD[i] + b3*DXXTRBMD[i]  +
    b4*DXXINBMD[i] + b5*DXXWDBMD[i] + b6*DXXOSBMD[i] + b7*DXXL1BMD[i] + b8*DXXL2BMD[i] +
    b9*DXXL3BMD[i] + b10*DXXL4BMD[i] + b11*OSQ130[i] + b12*OSQ170[i] + b13*OSQ200[i] +
    b14*SMQ020[i] + b15*ALQ101[i] + b16*DIQ010[i] + b17*MCQ160A[i] + b18*MCQ160C[i] +
    b19*MCQ160L[i] + b20*BMXBMI[i] + b21*DBQ197[i] + b22*DBQ229[i] + b23*RIAGENDR[i] +
    b24*RIDRETH1[i] +b25*RIDAGEYR[i]
    fracture[i] ~ dbern(p[i])
}


# Specifying prior distributions
a ~ dnorm(0,0.01)
b1 ~ dnorm(0,0.01)
b2 ~ dnorm(0,0.01)
b3 ~ dnorm(0,0.01)
b4 ~ dnorm(0,0.01)
b5 ~ dnorm(0,0.01)
b6 ~ dnorm(0,0.01)
b7 ~ dnorm(0,0.01)
b8 ~ dnorm(0,0.01)
b9 ~ dnorm(0,0.01)
b10 ~ dnorm(0,0.01)
b11 ~ dnorm(0,0.01)
b12 ~ dnorm(0,0.01)
b13 ~ dnorm(0,0.01)
b14 ~ dnorm(0,0.01)
b15 ~ dnorm(0,0.01)
b16 ~ dnorm(0,0.01)
b17 ~ dnorm(0,0.01)
b18 ~ dnorm(0,0.01)
b19 ~ dnorm(0,0.01)
b20 ~ dnorm(0,0.01)
b21 ~ dnorm(0,0.01)
b22 ~ dnorm(0,0.01)
b23 ~ dnorm(0,0.01)
b24 ~ dnorm(0,0.01)
b25 ~ dnorm(0,0.01)

}

",file = "blogistic.txt")

# Step3: Run the MCMC 
# parameters
params  <- c("a","b1","b2","b3","b4","b5","b6","b7","b8","b9","b10",
             "b11","b12","b13","b14","b15","b16","b17","b18","b19","b20","b21",
             "b22","b23","b24","b25")
# run MCMC
set.seed(1)
model<-jags(data=jagsdata, parameters.to.save=params, model.file="blogistic.txt",
    n.chains=3, n.iter=20000, n.burnin=500,
    n.thin=1,quiet = TRUE)
model_men <-jags(data=jagsdata_men, parameters.to.save=params, model.file="blogistic.txt",
    n.chains=3, n.iter=20000, n.burnin=500,
    n.thin=1,quiet = TRUE)
model_women <-jags(data=jagsdata_women, parameters.to.save=params, model.file="blogistic.txt",
    n.chains=3, n.iter=20000, n.burnin=500,
    n.thin=1,quiet = TRUE)
# Step4: Check convergence
if(T){
SArray<- model$BUGSoutput$sims.array
for(i in 1:length(params)){ 
    nn<-params[i]
    # Autocorrelation plot
    acf( SArray[,1,nn], lag.max = 50,
         main=paste("Autocorrelation plot of",nn,"(chain1)"))
    acf( SArray[,2,nn], lag.max = 50,
         main=paste("Autocorrelation plot of",nn,"(chain2)")) 
    acf( SArray[,3,nn], lag.max = 50,
         main=paste("Autocorrelation plot of",nn,"(chain3)"))
    # trace plot
    matplot(501:20000,SArray[,,nn], 
            main=paste("Trace plot of",nn),
            xlab="interactions",ylab=nn,type="l") 
    }
}
# statistics
kable(model$BUGSoutput$summary[params,],dig=3,
      caption = "Statistics of the fitted parameters")
kable(model_men$BUGSoutput$summary[params,],dig=3,
      caption = "Statistics of the fitted parameters for men")
kable(model_women$BUGSoutput$summary[params,],dig=3,
      caption = "Statistics of the fitted parameters for women")
```


```{r visualization}
# use imputed values to do data visualization
fracture <-impute$fracture
gender <- impute$RIAGENDR
bmdtest <- select(impute,contains("BMD"))
bmdtest$fracture <- fracture
bmdtest$gender <- factor(gender,levels=c("1","2"),labels=c("male","female"))

colMeans(bmdtest[,-c(11,12)],na.rm = TRUE)
bmdtest2 <- pivot_longer(bmdtest, cols=starts_with("DXX"),names_to = "DXA_scans", 
                         values_to = "value",values_drop_na = TRUE)

# density plot of DXA values for males/females
ggplot(bmdtest2, aes(x=value,fill=gender))+
  facet_wrap(vars(DXA),ncol=4)+
  geom_density(alpha=0.4)+
  theme_minimal()+
  scale_fill_manual(values=c("lightblue","lightpink"))+
  labs(title = "Density Plot for BMD Values")

# density plot of DXA values for fracture/no fracture (contain NA)
ggplot(bmdtest2, aes(x=value,fill=fracture))+
  facet_wrap(vars(DXA),ncol=4)+
  geom_density(alpha=0.3)+
  theme_minimal()+
  labs(title = "Density Plot for BMD Values")

# mosaic plot of gender VS fracture
t <- table(bmdtest2$fracture, bmdtest2$gender)
mosaicplot(t, color = c("lightblue", "lightpink"),xlab = "Oseoporosis Fracture", 
           ylab = "Gender",main = NA)
```
