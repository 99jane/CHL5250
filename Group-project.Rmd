---
title: "Group project"
author: "Yun Zhu"
date: "28/02/2022"
output: pdf_document
---

```{r setup, include=FALSE}
library(haven)
library(naniar)
library(gtsummary)
library(pROC)
library(dplyr)
library(caret)
library(polycor)
library(tidyr)
library(Hmisc)
library(mice)
library(here)
library(knitr)
library(glmnet)
library(rstanarm)

frax_risk <- read_sas(here("data","frax_risk.sas7bdat"), NULL)
frax_risk <-as.data.frame(frax_risk)
```


```{r check missing value}
# delete the observations first
# 
# replace "don't know" and "refused" with NA
# add MCQ160A and MCQ160L bcs they have "9" in them
dn9<-c("MCQ160L","MCQ160A","ALQ101","DBQ197","DBQ229","DIQ010","DIQ220","MCQ190",
       "MCQ160C","OSQ010A","OSQ010B","OSQ010C","OSQ040AA","OSQ040BA","OSQ040CA",
       "OSQ070","OSQ130","OSQ170","OSQ200","OSQ140U","SMQ020")
dn999<-c("ALQ130","ALQ140Q","DID040","OSQ140Q")
dn9999<-c("OSQ020A","OSQ020B","OSQ020C","WHD020","WHD110","WHD010")
# no column named WHD140 in this data set
dn99999<-c("MCQ160A","MCQ180A","MCQ180C","MCQ160L","MCQ170L","MCQ180L")
frax_risk[,dn9]<-na_if(frax_risk[,dn9],9)
frax_risk[,dn9]<-na_if(frax_risk[,dn9],7)
frax_risk[,dn999]<-na_if(frax_risk[,dn999],999)
frax_risk[,dn999]<-na_if(frax_risk[,dn999],777)
frax_risk[,dn9999]<-na_if(frax_risk[,dn9999],9999)
frax_risk[,dn9999]<-na_if(frax_risk[,dn9999],7777)
frax_risk[,dn99999]<-na_if(frax_risk[,dn99999],99999)
frax_risk[,dn99999]<-na_if(frax_risk[,dn99999],77777)
# check missing values of all variables
gg_miss_var(frax_risk, show_pct = TRUE)
# pick variables with missing value proportion over 50%
frax_risk_50<-frax_risk[, which(colMeans(is.na(frax_risk)) > 0.5)]
gg_miss_var(frax_risk_50, show_pct = TRUE)
```

```{r check variables with missing value less than 50%}
# missing value more than 20%
frax_risk_2050<-frax_risk[, which((colMeans(is.na(frax_risk)) <= 0.5)&(colMeans(is.na(frax_risk)) > 0.2))]
gg_miss_var(frax_risk_2050, show_pct = TRUE)
length(frax_risk_2050)
# missing value less than 20%
frax_risk_20<-frax_risk[, which(colMeans(is.na(frax_risk)) <= 0.2)]
gg_miss_var(frax_risk_20, show_pct = TRUE)
```

```{r dataframe}
# create a data frame 
df<-frax_risk[, which(colMeans(is.na(frax_risk)) <= 0.4)]
# remove duplicate rows
df<-distinct(df)
# check features with low variance
nearZeroVar(df,saveMetrics = TRUE)
# check features with high correlation
Corr <- NULL
# Chi-square test between two categorical variables. 
# Pearson’s Test between two continuous variables
# Point-Biserial Correlation One categorical and one quantitative variable.
discrete <- c("RIAGENDR","RIDRETH1","SDMVPSU","OSQ010A","OSQ010B","OSQ010C","OSQ130","OSQ170","OSQ200","SMQ020" ,               "ALQ101","ALQ130","ALQ140Q","DIQ010","MCQ160A","MCQ160C","MCQ160L","DBQ197","DBQ229")

complete <- na.omit(df)
for(i in 2:(ncol(complete)-1)){
  for(j in (i+1):ncol(complete)){
    if((names(complete)[i] %in% discrete + names(complete)[j] %in% discrete) != 1){
      Corr <- rbind(Corr, c(names(complete)[i],names(complete)[j], cor.test(complete[,i], complete[,j], method = "pearson")$estimate))
    }else
      Corr <- rbind(Corr, c(names(complete)[i],names(complete)[j], polyserial(complete[,i],complete[,j])))
  }
}
#Corr(BMXBMI, WHD020) = 0.83974550051039
df <-  subset(df, select = -c(SEQN,WHD010,WHD020,WHD110))
df <- df[-which(is.na(df$OSQ010A)|is.na(df$OSQ010B)|is.na(df$OSQ010C)),]

(fmla <- as.formula(paste(" ~ ", paste(colnames(df), collapse=" +"))))
impute_arg <- aregImpute(formula = fmla, data = df, n.impute = 10, nk=0 )

# Get the imputed values
impute <- impute.transcan(impute_arg, data=df, imputation=1, list.out=TRUE, pr=FALSE, check=FALSE)

# convert the list to the database
impute <- as.data.frame(do.call(cbind,impute))
format(colSums(is.na(df[, sapply(df, anyNA)])) / nrow(df)*100, digits = 2) #DXXOSBMD 
index.na <- which(is.na(df$DXXOSBMD))
Comparison <- data.frame(DXXOSBMD = c(df$DXXOSBMD[-index.na],impute$DXXOSBMD[index.na]),
                         Label = c(rep("Observed",(nrow(impute)-length(index.na))),rep("imputed",length(index.na))))
require(qqplotr)

# Histogram with density plot
p1 <- ggplot(Comparison, aes(DXXOSBMD, colour = Label)) + 
 geom_histogram(aes(y=..density..), colour="lightblue", fill="white")+
 geom_density(alpha=.2, fill="#FF6666") 

# Interleaved histograms
p2 <- ggplot(Comparison, aes(DXXOSBMD, colour = Label)) +
  geom_histogram(fill="white", alpha=0.5)+
  theme(legend.position="right")

#quantile–quantile 
p3 <- ggplot(data = Comparison, mapping = aes(sample = DXXOSBMD, color = Label,fill = Label)) +
    stat_qq_band(alpha=0.3) +
    stat_qq_line() +
    stat_qq_point(alpha=0.1) +
    labs(x = "DXXOSBMD Observed", y = "DXXOSBMD Imputed")
#cumulative distribution
p4 <- ggplot(Comparison, aes(DXXOSBMD, colour = Label)) +
  stat_ecdf() +
    labs(x = "DXXOSBMD", y = "Cumulative Probability")
library(cowplot)
ggdraw() +
  draw_plot(p1, x = 0, y = .5, width = .5, height = .5) +
  draw_plot(p2, x = .5, y = .5, width = .5, height = .5) +
  draw_plot(p3, x = 0, y = 0, width = .5, height = 0.5) +
  draw_plot(p4, x = 0.5, y = 0, width = .5, height = 0.5)

```

```{r}
table <- 
  tbl_summary(
    impute,
    by = RIAGENDR # split table by group
  ) %>%
  add_n() %>% # add column with total number of non-missing observations
  add_p() %>% # test for a difference between groups
  modify_header(label = "**Variable**") %>% # update the column header
  bold_labels() 
table
```
```{r Bayesian}

############# Step 0: prepare features for modeling ########
df.b <-impute %>% 
  mutate(fracture=as.factor(ifelse((OSQ010A=="1"|OSQ010B=="1"|OSQ010C=="1"), 1, 0)))

# groups of variables  
fracture_variables<-c("OSQ010A","OSQ010B","OSQ010C","fracture")
individual_variables<-names(df.b)[1:3]
sampling_variables <- names(df.b)[4:6]
BMD_variables<-names(dplyr::select(df.b,contains("BMD")))
frax_risk_nonBMD<-df.b[,!(names(df.b) %in% BMD_variables) 
                       & !(names(df.b) %in% fracture_variables)
                       & !(names(df.b) %in% individual_variables)
                       & !(names(df.b) %in% sampling_variables)]
nonBMD_variables<-names(frax_risk_nonBMD)

# reformat
df.b$RIAGENDR <- as.factor(df.b$RIAGENDR)
df.b$RIDRETH1 <- as.factor(df.b$RIDRETH1)
df.b[,nonBMD_variables[-10]] <- lapply(df.b[,nonBMD_variables[-10]],factor)
df.b[,fracture_variables] <- lapply(df.b[,fracture_variables],factor)
df.b[,BMD_variables] <- lapply(df.b[,BMD_variables],scale)
df.b[,nonBMD_variables[10]] <- scale(df.b[,nonBMD_variables[10]])

# split data set into men and women
df.b.m<-df.b%>%filter(RIAGENDR==1)
df.b.w<-df.b%>%filter(RIAGENDR==2)

################# step 1:  Priors ##############
prior <- normal(0,2.5)

################ Step 2:  Model building (for Men),use un-weighted one to compute  
# expected log predictive density (elpd) and compare models  ##
library(loo)
table(df.b.m$fracture)
# 0    1 
# 2511  393 
library(ROSE)
df.b.m_re <- ovun.sample(fracture ~ ., data = df.b.m, method = "both", 
                            seed = 1470, N = 1200, p=0.5)$data
n.m <- dim(df.b.m_re)[1]
set.seed(1470)
train <- sample(n.m,round(2*n.m/3))
data.tr <- df.b.m_re[train,]
data.te <- df.b.m_re[-train,]
y.te <- df.b.m_re[-train,"fracture"]

# 1. baseline model
# drop age first since it is highly correlated with MCQ160C and DXXWDBMD
features <- c(nonBMD_variables,BMD_variables,"RIDRETH1")
reg.formula0 <- formula(paste("fracture ~", paste(features, collapse = " + ")))
post0 <- stan_glm(reg.formula0, data = data.tr,
                  family = binomial(link = "logit"),
                  QR=TRUE, chains = 3,iter = 5000,prior = prior, prior_intercept = prior,
                  refresh=0, seed =1470)
loo_0 <- rstanarm::loo(post0, save_psis = TRUE)
elpd_0 <- loo_0$estimates[1,1]
# 2. compare and update models
post <- NULL
k <- length(features)
while(k>0){
  elpd <- NULL
  for (i in 1:length(features)){
    reg.formula <- formula(paste("fracture ~", paste(features[-i], collapse = " + ")))
    post[[i]] <- stan_glm(reg.formula, data = data.tr,
                          family = binomial(link = "logit"),
                          QR=TRUE, chains = 3,iter = 5000,prior = prior, prior_intercept = prior,
                          refresh=0, seed =1470)
    elpd[i] <- rstanarm::loo(post[[i]],k_threshold = 0.7)$estimate[1,1]
  }
  elpd <- c(elpd,elpd_0)
  if (which.max(elpd) < length(features)+1){
    features <- features[-which.max(elpd)]
    reg.formula0 <- formula(paste("fracture ~", paste(features, collapse = " + ")))
    post0 <- stan_glm(reg.formula0, data = data.tr,
                      family = binomial(link = "logit"),
                      QR=TRUE, chains = 3,iter = 5000,prior = prior, prior_intercept = prior,
                      refresh=0, seed =1470)
    loo_0 <- rstanarm::loo(post0, k_threshold = 0.7)
    elpd_0 <- loo_0$estimates[1,1]
    k <- which.max(elpd)
  }
  else {
    k <- 0
  }
}
reg.formula0
# for Men: fracture ~ ALQ101 + DIQ010 + MCQ160A + MCQ160L + DXXOFBMD + DXXNKBMD + 
#                     DXXTRBMD + DXXWDBMD + DXXOSBMD + RIDRETH1
post.m <- post0
features.m <- features
pred.m <-colMeans(posterior_epred(post.m,newdata = data.te,seed =1470))
roc(response=y.te,predictor=pred.m,quiet= T)$auc
# 0.6054
# 3. plots
library(bayesplot)
posterior.m <- as.matrix(post.m)
p.m.1<- mcmc_areas(posterior.m, prob = 0.95, 
           pars = grep(pattern = "BMD", x = features.m, value = TRUE)) +
  ggtitle("Posterior distributions of BMD variables (MEN)",
          "with medians and 95% intervals") + 
  xlab('coeffients') +
  ylab('variables') +
  theme(text = element_text(family = "Arial"))

p.m.2<- mcmc_intervals(posterior.m, prob = 0.95, prob_outer = 0.95,
                   pars = names(post.m$coefficients)[-c(7:11)]) +
  ggtitle("Posterior intervals of other variables (MEN)",
          "with medians and 95% intervals") + 
  xlab('coeffients') +
  ylab('variables') +
  theme(text = element_text(family = "Arial"))

# dynamic ones
#launch_shinystan(post.m, ppd = FALSE)
# 4. table
library(kableExtra)
save_kable(kable(post.m$stan_summary[,c(1:4,10)],digits = 3),file = "./plot/fracture_men.png")
################# Step 3:  Model building (for Women)######
table(df.b.w$fracture)
# 0    1 
# 2695  323 
df.b.w_re <- ovun.sample(fracture ~ ., data = df.b.w, method = "both", 
                         seed = 1470, N = 1200, p=0.5)$data
n.w <- dim(df.b.w_re)[1]
set.seed(1470)
train <- sample(n.w,round(2*n.w/3))
data.tr <- df.b.w_re[train,]
data.te <- df.b.w_re[-train,]
y.te <- df.b.w_re[-train,"fracture"]
# 1. baseline model
features <- c(nonBMD_variables,BMD_variables,"RIDRETH1")
reg.formula0 <- formula(paste("fracture ~", paste(features, collapse = " + ")))
post0 <- stan_glm(reg.formula0, data = data.tr,
                  family = binomial(link = "logit"),
                  QR=TRUE, chains = 3,iter = 5000,prior = prior, prior_intercept = prior,
                  refresh=0, seed =1470)
loo_0 <- rstanarm::loo(post0, save_psis = TRUE)
elpd_0 <- loo_0$estimates[1,1]
# 2. compare and update models
post <- NULL
k <- length(features)
while(k>0){
  elpd <- NULL
  for (i in 1:length(features)){
    reg.formula <- formula(paste("fracture ~", paste(features[-i], collapse = " + ")))
    post[[i]] <- stan_glm(reg.formula, data = data.tr,
                          family = binomial(link = "logit"),
                          QR=TRUE, chains = 3,iter = 5000,prior = prior, prior_intercept = prior,
                          refresh=0, seed =1470)
    elpd[i] <- rstanarm::loo(post[[i]],k_threshold = 0.7)$estimate[1,1]
  }
  elpd <- c(elpd,elpd_0)
  if (which.max(elpd) < length(features)+1){
    features <- features[-which.max(elpd)]
    reg.formula0 <- formula(paste("fracture ~", paste(features, collapse = " + ")))
    post0 <- stan_glm(reg.formula0, data = data.tr,
                      family = binomial(link = "logit"),
                      QR=TRUE, chains = 3,iter = 5000,prior = prior, prior_intercept = prior,
                      refresh=0, seed =1470)
    loo_0 <- rstanarm::loo(post0, k_threshold = 0.7)
    elpd_0 <- loo_0$estimates[1,1]
    k <- which.max(elpd)
  }
  else {
    k <- 0
  }
}
reg.formula0
# for Women: fracture ~ OSQ200 + SMQ020 + MCQ160A + DBQ197 + DXXNKBMD + DXXWDBMD + 
#             DXXOSBMD + DXXL1BMD + DXXL2BMD + DXXL3BMD + DXXL4BMD + RIDRETH1

post.w <- post0
features.w <- features
pred.w <-colMeans(posterior_epred(post.w,newdata = data.te,seed =1470))
roc(response=y.te,predictor=pred.w,quiet= T)$auc
# 0.6434
# 3. plots
posterior.w <- as.matrix(post.w)
p.w.1<- mcmc_areas(posterior.w, prob = 0.95, 
                   pars = grep(pattern = "BMD", x = features.w, value = TRUE)) +
  ggtitle("Posterior distributions of BMD variables (WOMEN)",
          "with medians and 95% intervals") + 
  xlab('coeffients') +
  ylab('variables') +
  theme(text = element_text(family = "Arial"))

p.w.2<- mcmc_intervals(posterior.w, prob = 0.95, prob_outer = 0.95,
                       pars = names(post.w$coefficients)[-c(9:15)]) +
  ggtitle("Posterior intervals of other variables (WOMEN)",
          "with medians and 95% intervals") + 
  xlab('coeffients') +
  ylab('variables') +
  theme(text = element_text(family = "Arial"))

# dynamic ones
#launch_shinystan(post.w, ppd = FALSE)

# 4.table
save_kable(kable(post.w$stan_summary[,c(1:4,10)],digits = 3),file = "./plot/fracture_women.png")
################# Step 4:  Model building (Hip fracture for Men and Women)######
df.b.m <- df.b.m %>%
  mutate(OSQ010A=as.factor(ifelse(OSQ010A=="1","1","0")))
df.b.w <- df.b.w %>%
  mutate(OSQ010A=as.factor(ifelse(OSQ010A=="1","1","0")))
## Men:
df.b.m_re <- ovun.sample(OSQ010A ~ ., data = df.b.m, method = "both", 
                            seed = 1470, N = 1200, p=0.5)$data
n.m <- dim(df.b.m_re)[1]
set.seed(1471)
train <- sample(n.m,round(2*n.m/3))
data.tr <- df.b.m_re[train,]
data.te <- df.b.m_re[-train,]
y.te <- df.b.m_re[-train,"OSQ010A"]
# 1. baseline model
features <- c(nonBMD_variables,BMD_variables,"RIDRETH1")
reg.formula0 <- formula(paste("OSQ010A ~", paste(features, collapse = " + ")))
post0 <- stan_glm(reg.formula0, data = data.tr,
                  family = binomial(link = "logit"),
                  QR=TRUE, chains = 3,iter = 5000,prior = prior, prior_intercept = prior,
                  refresh=0, seed =1471)
loo_0 <- rstanarm::loo(post0,save_psis = TRUE)
elpd_0 <- loo_0$estimates[1,1]
# 2. compare and update models
post <- NULL
k <- length(features)
while(k>0){
  elpd <- NULL
  for (i in 1:length(features)){
    reg.formula <- formula(paste("OSQ010A ~", paste(features[-i], collapse = " + ")))
    post[[i]] <- stan_glm(reg.formula, data = data.tr,
                          family = binomial(link = "logit"),
                          QR=TRUE, chains = 3,iter = 5000,prior = prior, prior_intercept = prior,
                          refresh=0, seed =1470)
    elpd[i] <- rstanarm::loo(post[[i]])$estimate[1,1]
  }
  elpd <- c(elpd,elpd_0)
  if (which.max(elpd) < length(features)+1){
    features <- features[-which.max(elpd)]
    reg.formula0 <- formula(paste("OSQ010A ~", paste(features, collapse = " + ")))
    post0 <- stan_glm(reg.formula0, data = data.tr,
                      family = binomial(link = "logit"),
                      QR=TRUE, chains = 3,iter = 5000,prior = prior, prior_intercept = prior,
                      refresh=0, seed =1470)
    loo_0 <- rstanarm::loo(post0)
    elpd_0 <- loo_0$estimates[1,1]
    k <- which.max(elpd)
  }
  else {
    k <- 0
  }
}
reg.formula0

# OSQ010A ~ OSQ170 + SMQ020 + DIQ010 + MCQ160A + MCQ160C + BMXBMI + 
# DBQ197 + DBQ229 + DXXOFBMD + DXXNKBMD + DXXTRBMD + DXXINBMD + 
#  DXXWDBMD + DXXOSBMD + DXXL1BMD + DXXL2BMD + DXXL3BMD + DXXL4BMD + 
#  RIDRETH1

post.m <- post0
features.m <- features
pred.m <-colMeans(posterior_epred(post.m,newdata = data.te,seed =1470))
roc(response=y.te,predictor=pred.m,quiet= T)$auc
#0.8368
# 3. plots
posterior.m <- as.matrix(post.m)
p.m.3<- mcmc_areas(posterior.m, prob = 0.95, 
                   pars = grep(pattern = "BMD", x = features.m, value = TRUE)) +
  ggtitle("Posterior distributions of BMD variables (WOMEN)",
          "with medians and 95% intervals") + 
  xlab('coeffients') +
  ylab('variables') +
  theme(text = element_text(family = "Arial"))

p.m.4<- mcmc_intervals(posterior.m, prob = 0.95, prob_outer = 0.95,
                       pars = names(post.m$coefficients)[-c(15:24)]) +
  ggtitle("Posterior intervals of other variables (WOMEN)",
          "with medians and 95% intervals") + 
  xlab('coeffients') +
  ylab('variables') +
  theme(text = element_text(family = "Arial"))

# dynamic ones
#launch_shinystan(post.m, ppd = FALSE)

# 4.table
save_kable(kable(post.m$stan_summary[,c(1:4,10)],digits = 3),file = "./plot/hip_fracture_men.png")

## Women:
df.b.w_re <- ovun.sample(OSQ010A ~ ., data = df.b.w, method = "both", 
                         seed = 1470, N = 1200, p=0.5)$data
n.w <- dim(df.b.w_re)[1]
set.seed(1470)
train <- sample(n.w,round(2*n.w/3))
data.tr <- df.b.w_re[train,]
data.te <- df.b.w_re[-train,]
y.te <- df.b.w_re[-train,"OSQ010A"]
# 1. baseline model
features <- c(nonBMD_variables,BMD_variables,"RIDRETH1")
reg.formula0 <- formula(paste("OSQ010A ~", paste(features, collapse = " + ")))
post0 <- stan_glm(reg.formula0, data = data.tr,
                  family = binomial(link = "logit"),
                  QR=TRUE, chains = 3,iter = 5000,prior = prior, prior_intercept = prior,
                  refresh=0, seed =1470)
loo_0 <- rstanarm::loo(post0,k_threshold = 0.7)
elpd_0 <- loo_0$estimates[1,1]
# 2. compare and update models
post <- NULL
k <- length(features)
while(k>0){
  elpd <- NULL
  for (i in 1:length(features)){
    reg.formula <- formula(paste("OSQ010A ~", paste(features[-i], collapse = " + ")))
    post[[i]] <- stan_glm(reg.formula, data = data.tr,
                          family = binomial(link = "logit"),
                          QR=TRUE, chains = 3,iter = 5000,prior = prior, prior_intercept = prior,
                          refresh=0, seed =1470)
    elpd[i] <- rstanarm::loo(post[[i]],k_threshold = 0.7)$estimate[1,1]
  }
  elpd <- c(elpd,elpd_0)
  if (which.max(elpd) < length(features)+1){
    features <- features[-which.max(elpd)]
    reg.formula0 <- formula(paste("OSQ010A ~", paste(features, collapse = " + ")))
    post0 <- stan_glm(reg.formula0, data = data.tr,
                      family = binomial(link = "logit"),
                      QR=TRUE, chains = 3,iter = 5000,prior = prior, prior_intercept = prior,
                      refresh=0, seed =1470)
    loo_0 <- rstanarm::loo(post0, save_psis = TRUE,k_threshold = 0.7)
    elpd_0 <- loo_0$estimates[1,1]
    k <- which.max(elpd)
  }
  else {
    k <- 0
  }
}
reg.formula0

# OSQ010A ~ OSQ130 + SMQ020 + ALQ101 + DIQ010 + MCQ160A + MCQ160C + 
# MCQ160L + BMXBMI + DBQ197 + DBQ229 + DXXOFBMD + DXXNKBMD + 
#  DXXTRBMD + DXXINBMD + DXXWDBMD + DXXOSBMD + DXXL1BMD + RIDRETH1

post.w <- post0
features.w <- features
pred.w <-colMeans(posterior_epred(post.w,newdata = data.te,seed =1470))
roc(response=y.te,predictor=pred.w,quiet= T)$auc
# 0.849
# 3. plots
posterior.w <- as.matrix(post.w)
p.w.3<- mcmc_areas(posterior.w, prob = 0.95, 
                   pars = grep(pattern = "BMD", x = features.w, value = TRUE)) +
  ggtitle("Posterior distributions of BMD variables (WOMEN)",
          "with medians and 95% intervals") + 
  xlab('coeffients') +
  ylab('variables') +
  theme(text = element_text(family = "Arial"))

p.w.4<- mcmc_intervals(posterior.w, prob = 0.95, prob_outer = 0.95,
                   pars = names(post.w$coefficients)[-c(17:23)]) +
  ggtitle("Posterior intervals of other variables (WOMEN)",
          "with medians and 95% intervals") + 
  xlab('coeffients') +
  ylab('variables') +
  theme(text = element_text(family = "Arial"))

# dynamic ones
#launch_shinystan(post.w, ppd = FALSE)

# 4.table
save_kable(kable(post.w$stan_summary[,c(1:4,10)],digits = 3),file = "./plot/hip_fracture_women.png")

p.m.1 <- p.m.1 +
  theme(text = element_text(size = 8,family = "Arial"))
p.m.2 <- p.m.2 +
  theme(text = element_text(size = 8,family = "Arial"))
p.m.3 <- p.m.3 +
  theme(text = element_text(size = 8,family = "Arial"))
p.m.4 <- p.m.4 +
  theme(text = element_text(size = 8,family = "Arial"))
p.w.1 <- p.w.1 +
  theme(text = element_text(size = 8,family = "Arial"))
p.w.2 <- p.w.2 +
  theme(text = element_text(size = 8,family = "Arial"))
p.w.3 <- p.w.3 +
  theme(text = element_text(size = 8,family = "Arial"))
p.w.4 <- p.w.4 +
  theme(text = element_text(size = 8,family = "Arial"))
library(ggpubr)
ggarrange(p.m.1, p.m.2, p.w.1, p.w.2,ncol = 2, nrow = 2)
ggsave("fracture.png",path = "./plot",device = "png")


ggarrange(p.m.3, p.m.4, p.w.3, p.w.4,ncol = 2, nrow = 2)
ggsave("hip_fracture.png",path = "./plot",device = "png")
```


```{r LASSO}
# Step 1: prepare features for modeling
impute<-impute[,-c(4:6)]
impute<-impute%>% mutate(fracture=as.factor(ifelse((OSQ010A=="1"|OSQ010B=="1"|OSQ010C=="1"), 1, 0)))
impute$fracture <- as.numeric(impute$fracture)-1
frax_risk_men<-impute%>%filter(RIAGENDR==1)
frax_risk_women<-impute%>%filter(RIAGENDR==2)

fracture_variables<-c("OSQ010A","OSQ010B","OSQ010C","fracture")
individual_variables<-c("RIAGENDR","RIDRETH1","RIDAGEYR")
frax_risk_BMD<-dplyr::select(impute,contains("BMD"))
frax_risk_nonBMD<-impute[,!(names(impute) %in% names(frax_risk_BMD)) 
                         & !(names(impute) %in% fracture_variables)
                         & !(names(impute) %in% individual_variables)]
BMD_variables<-colnames(frax_risk_BMD)
nonBMD_variables<-colnames(frax_risk_nonBMD)
impute$RIAGENDR <- as.factor(impute$RIAGENDR)
impute$RIDRETH1 <- as.factor(impute$RIDRETH1)
#q1
x1 <-scale(model.matrix(fracture~., impute[,!names(impute) %in% c("OSQ010A","OSQ010B","OSQ010C")])[,-1])
y1 <- impute$fracture
set.seed(123)
cv.l1 <- cv.glmnet(x1,y1,family="binomial",nfolds = 5,alpha=1,penalty.factor =c(rep(0,10),rep(1,10),rep(0,8)))
best_lambda.l1<-cv.l1$lambda.min
set.seed(123)
l.mod1<- glmnet(x1,y1,family="binomial",alpha=1,lambda = best_lambda.l1,penalty.factor =c(rep(0,10),rep(1,10),rep(0,8)))
coef.l.min1 <- coef(l.mod1)
feature1 <- rownames(coef.l.min1)[coef.l.min1[,1]!=0][-1]
BMDfeature1<-grep("BMD",feature1,value=T)
BMDfeature1

#q2
x.hip <-scale(model.matrix(OSQ010A~., impute[,!names(impute) %in% c("fracture","OSQ010B","OSQ010C")])[,-1])
y.hip <- impute$OSQ010A
set.seed(123)
cv.l.hip <- cv.glmnet(x.hip,y.hip,family="binomial",nfolds = 5,alpha=1,penalty.factor =c(rep(0,10),rep(1,10),rep(0,8)))
best_lambda.l.hip<-cv.l.hip$lambda.min
set.seed(123)
l.mod.hip<- glmnet(x.hip,y.hip,family="binomial",alpha=1,lambda = best_lambda.l.hip,penalty.factor =c(rep(0,10),rep(1,10),rep(0,8)))
coef.l.min.hip<- coef(l.mod.hip)
feature.hip <- rownames(coef.l.min.hip)[coef.l.min.hip[,1]!=0][-1]
BMDfeature.hip<-grep("BMD",feature.hip,value=T)
BMDfeature.hip
#q3
## men
x.men <-scale(model.matrix(fracture~., frax_risk_men[,!names(frax_risk_men) %in% c("RIAGENDR","OSQ010A","OSQ010B","OSQ010C")])[,-1])
y.men <- frax_risk_men$fracture
set.seed(123)
cv.l.men <- cv.glmnet(x.men,y.men,family="binomial",nfolds = 5,alpha=1,penalty.factor =c(rep(0,6),rep(1,10),rep(0,8)))
best_lambda.l.men<-cv.l.men$lambda.min
set.seed(123)
l.mod.men<- glmnet(x.men,y.men,family="binomial",alpha=1,lambda = best_lambda.l.men,penalty.factor =c(rep(0,6),rep(1,10),rep(0,8)))
coef.l.min.men <- coef(l.mod.men)
feature.men <- rownames(coef.l.min.men)[coef.l.min.men[,1]!=0][-1]
BMDfeature.men<-grep("BMD",feature.men,value=T)
BMDfeature.men

## women
x.women <-scale(model.matrix(fracture~., frax_risk_women[,!names(frax_risk_women) %in% c("RIAGENDR","OSQ010A","OSQ010B","OSQ010C")])[,-1])
y.women <- frax_risk_women$fracture
set.seed(123)
cv.l.women <- cv.glmnet(x.women,y.women,family="binomial",nfolds = 5,alpha=1,penalty.factor =c(rep(0,6),rep(1,10),rep(0,8)))
best_lambda.l.women<-cv.l.women$lambda.min
set.seed(123)
l.mod.women<- glmnet(x.women,y.women,family="binomial",alpha=1,lambda = best_lambda.l.women,penalty.factor =c(rep(0,6),rep(1,10),rep(0,8)))
coef.l.min.women <- coef(l.mod.women)
feature.women <- rownames(coef.l.min.women)[coef.l.min.women[,1]!=0][-1]
BMDfeature.women<-grep("BMD",feature.women,value=T)
BMDfeature.women

```{r Bootstraps with LASSO}
### Perform Bootstraps with LASSO ###
boot_rep = 500 # Number of Boot straps
variables<-c("RIAGENDR2", "RIDAGEYR", "RIDRETH12", "RIDRETH13","RIDRETH14","RIDRETH15","OSQ130", "OSQ170", "OSQ200", "SMQ020","DXXOFBMD", "DXXNKBMD", "DXXTRBMD", "DXXINBMD", "DXXWDBMD", "DXXOSBMD", "DXXL1BMD", "DXXL2BMD", "DXXL3BMD", "DXXL4BMD", "ALQ101","DIQ010", "MCQ160A", "MCQ160C", "MCQ160L", "BMXBMI", "DBQ197", "DBQ229")
BMDfeature.q1.boot<-data.frame(feature=variables)
res = lapply(1:boot_rep, function(seed) {
  # Generate Bootstrap rows
  set.seed(seed)
  bootrows = sample(1:nrow(impute), nrow(impute), replace = T)
  splitdf = impute[bootrows,]  
  # Bootstrapped data
  traindf = splitdf
  X_cont = scale(model.matrix(fracture~., traindf[,!names(traindf) %in% c("OSQ010A","OSQ010B","OSQ010C")])[,-1])
  Y_cont = traindf$fracture
  # Find best lambda
  cvfit_cont = glmnet::cv.glmnet(x= X_cont, y = Y_cont,nfolds = 5, family="binomial",
                                 alpha=1, penalty.factor =c(rep(0,10),rep(1,10),rep(0,8)))
  lambda = cvfit_cont$lambda.min
  ## Run Lasso
  fit_cont = glmnet::glmnet(x= X_cont, y = Y_cont, family="binomial", alpha = 1, 
                            penalty.factor =c(rep(0,10),rep(1,10),rep(0,8)), lambda = lambda)
  coef.l.min1 <- coef(fit_cont)[-1]
  BMDfeature.q1.boot[seed+1]<<-coef.l.min1
})
for (j in 1:boot_rep+1) {
  BMDfeature.q1.boot[j]<-ifelse(BMDfeature.q1.boot[j]== 0, 0, 1)
  }
BMDfeature.q1.boot$total = rowSums(BMDfeature.q1.boot[-1])
featureq1.boot<-BMDfeature.q1.boot$feature[BMDfeature.q1.boot$total>0.9*boot_rep]
BMDfeature1.boot<-grep("BMD",featureq1.boot,value=T)
BMDfeature1.boot
##"DXXWDBMD" "DXXL3BMD"

#q2
BMDfeature.q2.boot<-data.frame(feature=variables)
res = lapply(1:boot_rep, function(seed) {
  # Generate Bootstrap rows
  set.seed(seed)
  bootrows = sample(1:nrow(impute), nrow(impute), replace = T)
  splitdf = impute[bootrows,]  
  # Bootstrapped data
  traindf = splitdf
  X_cont = scale(model.matrix(OSQ010A~.,traindf[,!names(traindf) %in% c("fracture","OSQ010B","OSQ010C")])[,-1])
  Y_cont = traindf$OSQ010A
  # Find best lambda
  cvfit_cont = glmnet::cv.glmnet(x= X_cont, y = Y_cont,nfolds = 5, family="binomial",
                                 alpha=1, penalty.factor =c(rep(0,10),rep(1,10),rep(0,8)))
  lambda = cvfit_cont$lambda.min
  ## Run Lasso
  fit_cont = glmnet::glmnet(x= X_cont, y = Y_cont, family="binomial", alpha = 1, 
                            penalty.factor =c(rep(0,10),rep(1,10),rep(0,8)), lambda = lambda)
  coef.l.min1 <- coef(fit_cont)[-1]
  BMDfeature.q2.boot[seed+1]<<-coef.l.min1
})

for (j in 1:boot_rep+1) {
BMDfeature.q2.boot[j]<-ifelse(BMDfeature.q2.boot[j]== 0, 0, 1)
  }
BMDfeature.q2.boot$total = rowSums(BMDfeature.q2.boot[-1])
featureq2.boot<-BMDfeature.q2.boot$feature[BMDfeature.q2.boot$total>0.9*boot_rep]
BMDfeature2.boot<-grep("BMD",featureq2.boot,value=T)
BMDfeature2.boot

#q3
variables.q3<-c("RIDAGEYR", "RIDRETH1", "OSQ130", "OSQ170", "OSQ200", "SMQ020","DXXOFBMD", "DXXNKBMD", "DXXTRBMD", "DXXINBMD", "DXXWDBMD", "DXXOSBMD", "DXXL1BMD", "DXXL2BMD", "DXXL3BMD", "DXXL4BMD", "ALQ101","DIQ010", "MCQ160A", "MCQ160C", "MCQ160L", "BMXBMI", "DBQ197", "DBQ229")
#men
BMDfeature.q3.men.boot<-data.frame(feature=variables.q3)
res = lapply(1:boot_rep, function(seed) {
  # Generate Bootstrap rows
  set.seed(seed)
  bootrows = sample(1:nrow(frax_risk_men), nrow(frax_risk_men), replace = T)
  splitdf = frax_risk_men[bootrows,]  
  # Bootstrapped data
  traindf = splitdf
  X_cont = scale(model.matrix(fracture~., traindf[,!names(traindf) %in% c("RIAGENDR","OSQ010A","OSQ010B","OSQ010C")])[,-1])
  Y_cont = traindf$fracture
  # Find best lambda
  cvfit_cont = glmnet::cv.glmnet(x= X_cont, y = Y_cont,nfolds = 5, family="binomial",
                                 alpha=1, penalty.factor =c(rep(0,6),rep(1,10),rep(0,8)))
  lambda = cvfit_cont$lambda.min
  ## Run Lasso
  fit_cont = glmnet::glmnet(x= X_cont, y = Y_cont, family="binomial", alpha = 1, 
                            penalty.factor =c(rep(0,6),rep(1,10),rep(0,8)), lambda = lambda)
  coef.l.min1 <- coef(fit_cont)[-1]
  BMDfeature.q3.men.boot[seed+1]<<-coef.l.min1
})

for (j in 1:boot_rep+1) {
BMDfeature.q3.men.boot[j]<-ifelse(BMDfeature.q3.men.boot[j]== 0, 0, 1)
  }
BMDfeature.q3.men.boot$total = rowSums(BMDfeature.q3.men.boot[-1])
featureq3men.boot<-BMDfeature.q3.men.boot$feature[BMDfeature.q3.men.boot$total>0.9*boot_rep]
BMDfeature.q3.men.boot<-grep("BMD",featureq3men.boot,value=T)
BMDfeature.q3.men.boot

#women
BMDfeature.q3.women.boot<-data.frame(feature=variables.q3)
res = lapply(1:boot_rep, function(seed) {
  # Generate Bootstrap rows
  set.seed(seed)
  bootrows = sample(1:nrow(frax_risk_women), nrow(frax_risk_women), replace = T)
  splitdf = frax_risk_women[bootrows,]  
  # Bootstrapped data
  traindf = splitdf
  X_cont = scale(model.matrix(fracture~., traindf[,!names(traindf) %in% c("RIAGENDR","OSQ010A","OSQ010B","OSQ010C")])[,-1])
  Y_cont = traindf$fracture
  # Find best lambda
  cvfit_cont = glmnet::cv.glmnet(x= X_cont, y = Y_cont,nfolds = 5, family="binomial",
                                 alpha=1, penalty.factor =c(rep(0,6),rep(1,10),rep(0,8)))
  lambda = cvfit_cont$lambda.min
  ## Run Lasso
  fit_cont = glmnet::glmnet(x= X_cont, y = Y_cont, family="binomial", alpha = 1, 
                            penalty.factor =c(rep(0,6),rep(1,10),rep(0,8)), lambda = lambda)
  coef.l.min1 <- coef(fit_cont)[-1]
  BMDfeature.q3.women.boot[seed+1]<<-coef.l.min1
})

for (j in 1:boot_rep+1) {
BMDfeature.q3.women.boot[j]<-ifelse(BMDfeature.q3.women.boot[j]== 0, 0, 1)
  }
BMDfeature.q3.women.boot$total = rowSums(BMDfeature.q3.women.boot[-1])
featureq3women.boot<-BMDfeature.q3.women.boot$feature[BMDfeature.q3.women.boot$total>0.9*boot_rep]
BMDfeature.q3.women.boot<-grep("BMD",featureq3women.boot,value=T)
BMDfeature.q3.women.boot
```
```

```{r SVM}
# SVM
library(e1071)
library(caret)
# Q1: identify predictors (BMD) of osteoporotic fracture in whole cohort, men and women
data.svm <- impute
data.svm[,c(4:10,21:25,27:29)] <- lapply(impute[,c(4:10,21:25,27:29)],factor)
data1 <- data.svm[,!names(data.svm) %in% c("OSQ010A","OSQ010B","OSQ010C")]
set.seed(1234)
type <- c("linear","radial","polynomial")
cv.full <- c()
for (i in 1:3){
  mod <- tune.svm(fracture~.,kernel=type[i], #cost=c(0.1,0.5,1,5,10,50),
                  type="C-classification", tunecontrol=tune.control(cross=5),
                  data=data1, probability=FALSE)
  cv.full[i] <- mod$best.performance
}
svmfit = svm(fracture~.,kernel=type[which.min(cv.full)], 
             data=data1,cost=1)

# assess the feature importance
# method1 - failed
# library(rminer)
# fit1 <- fit(fracture~., data=data1, model="svm", C=1)
# svm.imp <- Importance(fit1, data=data1)

# method2
# A simple backwards selection, recursive feature elimination (RFE) algorithm
svmProfile <- rfe(data1[,-26], data1$fracture,
                  sizes = c(2, 5, 10, 20),
                  rfeControl = rfeControl(functions = rfFuncs,
                                          number = 20),
                  method = "svmRadial")

svmProfile$optVariables
################################################################################
## identify predictors (BMD) of osteoporotic fracture in men and women
# men
data1.men <- split(data1,data1$RIAGENDR,drop = TRUE)$`1`[,-1]
set.seed(1234)
cv.men <- c()
for (i in 1:3){
  mod <- tune.svm(fracture~.,kernel=type[i], #cost=c(0.1,0.5,1,5,10,50),
                  type="C-classification", tunecontrol=tune.control(cross=5),
                  data=data1.men, probability=FALSE)
  cv.men[i] <- mod$best.performance
}

svmProfile.men <- rfe(data1.men[,-25],data1.men$fracture,
                      sizes = c(2, 5, 10, 20),
                      rfeControl = rfeControl(functions = rfFuncs,
                                              number = 20),
                      method = "svmRadial")

svmProfile.men$optVariables

## women
data1.women <- split(data1,data1$RIAGENDR,drop = TRUE)$`2`[,-1]
set.seed(1234)
cv.women <- c()
for (i in 1:3){
  mod <- tune.svm(fracture~.,kernel=type[i], #cost=c(0.1,0.5,1,5,10,50),
                  type="C-classification", tunecontrol=tune.control(cross=5),
                  data=data1.women, probability=FALSE)
  cv.women[i] <- mod$best.performance
}

svmProfile.women <- rfe(data1.women[,-25],data1.women$fracture,
                        sizes = c(2, 5, 10, 20),
                        rfeControl = rfeControl(functions = rfFuncs,
                                                number = 20),
                        method = "svmRadial")

svmProfile.women$optVariables
###############################################################################
# Q2: which BMD measure is the best predictor of hip fracture
data2 <- data.svm[,!names(data.svm) %in% c("fracture","OSQ010B","OSQ010C")]
set.seed(1234)
cv.hip <- c()
for (i in 1:3){
  mod <- tune.svm(OSQ010A~.,kernel=type[i], #cost=c(0.1,0.5,1,5,10,50),
                type="C-classification", tunecontrol=tune.control(cross=5),
                data=data2, probability=FALSE)
  cv.hip[i] <- mod$best.performance
}

svmProfile.hip <- rfe(data2[,-which(names(data2)=="OSQ010A")],data2$OSQ010A,
                  sizes = c(2, 5, 10, 20),
                  rfeControl = rfeControl(functions = rfFuncs,
                                          number = 20),
                  method = "svmRadial")

svmProfile.hip$optVariables
```

```{r visualization}
fracture <-frax_risk1$fracture
gender <- frax_risk1$RIAGENDR
bmdtest <- frax_risk_BMD
bmdtest$fracture <- fracture
bmdtest$gender <- factor(gender,levels=c("1","2"),labels=c("male","female"))
gg_miss_var(bmdtest,show_pct = TRUE)
# currently remove missing values --> need multiple imputation later
colMeans(bmdtest[,-c(11,12)],na.rm = TRUE)
bmdtest2 <- pivot_longer(bmdtest, cols=starts_with("DXX"),names_to = "DXA", 
                         values_to = "value",values_drop_na = TRUE)

# density plot of DXA values for males/females
ggplot(bmdtest2, aes(x=value,fill=gender))+
  facet_wrap(vars(DXA),ncol=4)+
  geom_density(alpha=0.4)+
  theme_minimal()+
  scale_fill_manual(values=c("lightblue","lightpink"))+
  labs(title = "Density Plot for DXA Values")

# density plot of DXA values for facture/no fracture (contain NA)
ggplot(bmdtest2, aes(x=value,fill=fracture))+
  facet_wrap(vars(DXA),ncol=4)+
  geom_density(alpha=0.3)+
  theme_minimal()+
  labs(title = "Density Plot for DXA Values")

# mosaic plot of gender VS fracture
t <- table(bmdtest2$fracture, bmdtest2$gender)
mosaicplot(t, color = c("lightblue", "lightpink"),xlab = "Oseoporosis Fracture", 
           ylab = "Gender",main = NA)
```
